
\chapter{Implementation}

This section describes the implementation of social network site
and how the system scales.

The system is composed by the following components, as shown in figure \ref{fig:system_architecture}: At the first layer lives (1) the Social Networking engine, which runs all PHP scripts and described in section \ref{sec:implementaion_of_social_netowrk}. At the second layer lives (2) the Memcached caching system, which described in section \ref{sec:memcache_implementation}. At the third layer lives (3) the Social Network MySQL database, and (4) the CDO server - client components and the CDO repository. The Social Networking Engine at layer 1 is considered as the front end system and the CDO Client, the memcached nodes, the CDO Server and the repositories are considered as the back end system. 

\begin{figure}[h]
	\caption{The overall architecture of Social Network.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/system_architecture.pdf}
	\centering
	\label{fig:system_architecture}
\end{figure}

Achieving the scalability of the system, two system architectures are examined at two layers of the system: (1) We added more than one Social Network engine at the first layer of the system. In this implementation, in order to keep the file system in consistent mode we integraded Apache Zookeeper\cite{zookeeper_url}. (2) We added more than one memcached machines at the second layer in order to add more cpu capacity and improve the system response time.

\section{Implementation of Social Network}
\label{sec:implementaion_of_social_netowrk}
The social networking platform is implemented over the extensible Elgg social network framework\cite{elgg_url}.  Elgg is open source software written in PHP, uses MySQL for data persistence and supports jQuery~\cite{jquery_url} for client-side scripting.  The architecture of Elgg Social Network shown in figure ~\ref{fig:elgg_architecture}. The Model of the framework is structured around the following key concepts as shown in figure ~\ref{fig:elgg_entities}:
\begin{itemize}
\item \emph{Entities}, classes capturing social networking concepts: users, communities, application models. Elgg Core comes with four basic objects: ElggObject, ElggUser, ElggGroup, ElggSite, ElggSession, ElggCache and a lot of other classes necessary for the proper engine operation.
\item \emph{Metadata} describing and extending entities (e.g., a response to a question, a review of an application model, etc.).
\item  \emph{Relationships} connect two entities (e.g., user A is a friend of user B, user C is a contributor to an application model, etc.) and are persisted in the Social Network DB.
\item \emph{Annotations} are pieces of simple data attached to an entity that allow users to leave ratings, or other relevant feedback.
\end{itemize}
All Elgg objects inherit from ElggEntity, which provides the general attributes of an object. Elgg core comes with the following basic entities: ElggObject, ElggUser, ElggGroup, ElggSite, ElggSession, ElggCache, as well as other classes necessary for the operation of the engine.

\begin{figure}[h]
	\caption{The Elgg Engine Data model.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/elgg_data_model.png}
	\centering
	\label{fig:elgg_entities}
\end{figure}

Elgg comprises a core system that can be extended through plugins (examples are the Cart system or the handling of Application Models). Plugins add new functionality, can customize aspects of the Elgg engine, or change the representation of pages.
A plugin can create new objects (e.g., ApplicationObject) characterized (through inheritance of ElggEntity) by a numeric globally unique identifier (GUID), owner GUID, Access ID. Access ID encodes permissions ensuring that when a page requests data it does not touch data the current user does not have permissions on. 

Figure\ref{fig:elgg_architecture} shows the model, view, and control parts of Elgg's architecture. In a typical scenario, a web client requests an HTML page (e.g., the description of an application model).  The request arrives at the \emph{Controller}, which confirms that the application exists and instructs \emph{Model} to increase the view counter on the application model object. The controller dispatches the request to the appropriate handler (e.g., application model, component handler, community handler) which then turns the request to the view system. View pulls the information about the application model and creates the HTML page returned to the web client.


\begin{figure}[h]
	\caption{Architecture of the Elgg Social Networking engine.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/elgg_architecture.pdf}
	\centering
	\label{fig:elgg_architecture}
\end{figure}


The extensibility of Elgg can be established not by modifying the core system but by introducing new plug-ins which follow the MVC model. A new plug-in can create a new entity. Thus, each entity is characterized by a numeric Globally Unique Identifier and Access ID. The Access ID determines the permissions that other users have. Thus, when a page requests data, it never touches those data that the current user does not have permission to see. All plug-ins share a common structure of folders and PHP files, following the MVC model of figure~\ref{fig:elgg_architecture}. 

The hierarchy of a plug-in is shown in figure~\ref{fig:elgg_hierarchy}. 
Folder {\em actions} includes the actions applied on application models. Every active participation by the user is performed via an action. Logging in, creating, updating or deleting content are all generic categories of actions.
The {\em views} folder contains the {\em php} forms applied on application models, {\em river} events (Elgg terminology for live feeds). Viewss are responsible for creating the output for the client browser. Generally, this will be HTML, but it can be also JSON or other format. 
{\em Pages} overrides elements of core Elgg pages and can be from chunks of presentation output (like sidebars) down to individual html code.  
The {\em js} and {\em lib} folder provides javascript and {\em php} library functions. 
Finally, the {\em vendors} folders include third-party frameworks such as Twitter's bootstrap front-end~\cite{bootstrap_url}.
The most important file of a plug-in is the \emph{start.php} script, which contains the \emph{page handler}. Page handler is a function manages the plug-in pages enabling custom url redirect to a specific page. 
The plug-in initialization is also defined in the start.php and registers actions, events and determines the views. 

\begin{figure}[h]
	\caption{The structure of the application description plug-in.}
	\includegraphics[width=0.4\textwidth]{./fig/folder_hierarchy.png}
	\centering
	\label{fig:elgg_hierarchy}
\end{figure}

The execution history of deployments of application models and the description of those models is stored in the CAMEL information repository, which is implemented as an Eclipse CDO server. The exchange of information between Elgg and the CAMEL information repository is going through CDO Client who retrieves the information from CDO server and sent it to the Elgg over sockets.

\subsection{Scaling Social Network Engine}
\label{sec:engine_scale}

This subsection describes how the horizontal scale of Social Network engine achieved. At the layer 1 of figure~\ref{fig:elgg_architecture} lives the Apache2 server which as the stress test of the system shows in chapter~\ref{chapt:evaluation}, the Apache2 server takes a heavy load on CPU utilization. Therefore, we introduce more than one Apache2 Servers running the Social Networking Engine of Elgg Framework. 

The Social Networking Engine keeps some information in the file system instead of the Social Network DB. This information includes the profile photos of users and any other photo such as photos that users add to the community groups. Furthermore, the initial configuration of Social Networking Engine keeps in the file system some caching files representing some views which are independent from specific users and do not change among all users. This file system caching feature removed from the Social Network Engine because is more efficient to use memcached for the caching instead of the slow file system.

The Network File System (NFS) is used in order to all SN Engines have access to the same file system store. An NFS server installed in one of the SN Engines and all the other SN Engines have an NFS client accessing the remote file system.   

Distributing Social Network Engine was not an easy problem, so Apache ZooKeeper~\cite{zookeeper_url} is used to enable highly reliable distributed coordination among access to the file system storing by Social Networking Engine. 
Apache ZooKeeper provides a tree abstraction where every node in that tree (or znode) is a file on which a variety of simple operations can be performed. ZooKeeper orders operations on znodes so that they occur atomically. Therefore there is no need to use complex locking protocols to ensure that only one process can access a znode at a time. The tree represents a hierarchical namespace, so that many distinct distributed systems can use a single ZooKeeper instance without worrying about their files having the same name.

Social Networking Engine uses Apache ZooKeeper in order to keep consistent the file system in rear but possible scenarios such as two users try to upload in the same time a file to the same group. When a SN Engine wants to write a file in file system first locks the specific path and after finish the write operation releases the lock.


\section{User interface}
In this section described the User Interface of Social Network implementated based on 104 mock-ups created by HCI expert team. The key design objective of the social network platform is to create a strong bond between (i) software engineering services for managing and deploying cloud-targeted application models; and (ii) community-oriented facilities for communication and
collaboration between users. The interconnections between the two in the design of the user interface are depicted in Figure \ref{fig:two_aspects}.
The prototype implementation is publicly accessible on-line at http://socialnetwork.paasage.eu. 

\begin{figure}[h]
	\caption{The engineering \& social activities are seamlessly within the Platform.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/two_aspectes.png}
	\centering
	\label{fig:two_aspects}
\end{figure}

\subsection{User Interface Design}
The discrete entities, which bound together the Social Networking with model aspects of Platform are:
\begin{itemize}
\item \emph{Application Models}. An example is shown if figure \ref{fig:jenter_home}, consisting of a human friendly description (label 1 in fig.\ref{fig:jenter_home}), the Camel Description of the model (label 2 in fig.\ref{fig:jenter_home}), reviews about the model (label 3 in fig.\ref{fig:jenter_home}). An overview of engineering aspects such as version and runs (label 4 in fig.\ref{fig:jenter_home}) and an overview of social aspects such as share and watches (label 5 in fig.\ref{fig:jenter_home}) 
\item \emph{Components}. We have integrated the Chef supermarket components into Social Network Platform. The components help the DevOps users to generate their application models. 
\item \emph{Groups}.
\item \emph{Users}.
\end{itemize}

\begin{figure}[h]
	\caption{The application model home page}
	\includegraphics[width=1\textwidth,natwidth=200,natheight=150]{./fig/jenterprise_home_page.pdf}
	\centering
	\label{fig:jenter_home}
\end{figure}

\subsubsection{Gamification}
Following recent trends in social networks design and with the aim to motivate users active and regular participation in
the professional network, the design employs gamification features, namely use of video game elements to improve user experience and user engagement in non-game services and applications~\cite{deterding2011gamification}. One gamification feature in the Social Network design is the reward system for active community members. As users contribute content (models, components, ratings, reviews, questions, or answers) they receive experience points leading to special badges visible to all community members. Other features are the Profile completeness bar with suggestions on how to increase it. Finally, the concept of Model badges awarded to application and component models in case of excelling performance. Badges can serve among others as goal-setting devices, status symbols, and indications of reputation assessment procedures~\cite{antin2011badges}.


 In order to support those look \& feel and the functionality of those mock-ups 25K lines of php, js and css code is written.

\section{Memcache}
\label{sec:memcache_implementation}
This section describes the experience gained by using memcached\cite{memcache_url}. Memcached is an open source, high-performance, distributed memory object caching system. We choose memcached, because is a generic simple in-memory key-value store. It has a powerful API available for PHP. After memcached integration the system increase the response time and performance.

Memcached added in layer 2 of system architecture and used for storing the following key-value tuples: (1) values from Social Network Database such as entities of Social Network, applications, components, users, group discussions, (2) evaluated javascript code results and (3) executions histories from repository of application models. Storing the executions of applications at Memcached the response time of the system increased because the PHP modules do not need to go through the heavy CDO client but get directly the executions of applications from Memcached.

The apache jmeter\cite{jmeter_url} was used to measure the responce time of the system and the sysstat tool\cite{sysstat_url} was used to measure the cpu usage. Section \ref{sec:eval_memcache} 
 shows the performance results of this implementation.

All tuples at Memcached are inserted with maximum key expiration time of thirty days. When a value in social network is updated, the memcached key will deleted~\ref{fig:memcache_key_value}.

\begin{figure}[h]
	\caption{The scenario a depicts a request from memcached when the key does not exist and scenario b depicts a updated operation of a value) }
	\includegraphics[width=0.9\textwidth]{./fig/memcached_key_value.pdf}
	\centering
	\label{fig:memcache_key_value}
\end{figure}

\section{Natural Language Processing and classification}
\label{sec:natural_implementation}
Natural Language Processing(NLP)~\cite{manning1999foundations} is a feature added to the Social Network. NLP is used in the interactions between the users and the SN and in the way the platform can understand and determine the type of user input. Particularly, Natural Language Understanding using Naivy Bayes algorithm is added to SN. The Natural framework~\cite{nodenatural_url} implemented with node.js. In general, Machine Learning algorithms such as Naivy Bayes, want an input data set of training data. This data is pulled from StackOverflow (SO) questions. Those questions are an excellent repository to train the NB algorithm.

\textcolor{red}{In general, the main actions of SO members is shown in figure~\ref{fig:stackoverflow_questions}. When users ask questions in SO, they must specify some tags describing their questions. A tag is a keyword or label that categorizes their question with other, similar questions. The users of SO sometimes, try to add as much tags as possible in order to make their questions popular and get them answered. SO restricts the users to add up to five tags in each of their questions. After a question is posed, the community of SO can vote up or down the question or privileged users can flagged the question as \emph{duplicate}, \emph{off-topic}, \emph{unclear}, \emph{too board}, \emph{primarily opinion-based}. So low quality questions will can be removed from the site and keep the questions repository clear and helpful to other potential DevOps.}

\textcolor{red}{For the training sets, which is the data to train the NB algorithm, the most voted question of the SO community is used. Those questions have emerged as the good questions in their fields and surely, we avoid the case to use a training set with miss-tagged questions which would result a miss-guided NLP classification. The NLP training set is retrieved from SO site using the stack exchange(SE) API~\cite{stackexchange_url}. The SE API is a powerful API, which allows to take the questions, the answers, the users and all the information that exists in SO site through a programming interface.} 

\begin{figure}[h]
	\caption{The main StackOverflow users' actions and NLP Classifier. }
	\includegraphics[width=0.9\textwidth]{./fig/StackOverFlow.pdf}
	\centering
	\label{fig:stackoverflow_questions}
\end{figure}

The first training set of our Natural Processing Tool consisted of five tags, relative to our platform. Those tags were: \emph{scalability}, \emph{reliability}, \emph{design}, \emph{performance} and \emph{optimization} with thirty questions per tag. For each of the tags, the thirty most voted questions from StackOverflow were retrieved and classified to each specific tag. Those exactly tags, after classification, are transformed in classes in NLP classification, as shows the figure~\ref{fig:stackoverflow_questions}

Every time a user asks a question to a platform's community, the classifier determines the class of the question. Then, if the platform is able to determine a heuristic answer, it will post it to the user's question. All the users of the platform can vote up or down this answer, depending on its accuracy, or provide their own answers.

The second training set of Natural Processing Tool was retrieved by automatically discovering tags. NB is trained with 10K questions from StackOverflow Q\&A site, fifty questions per tag. The general algorithm is shown below. Firstly, the algorithm starts with a tag which is relevant to the Social Network Platform such as \emph{scalability} at line 01. Afterwards, using the SE API the algorithm gets the 5 most voted questions tagged with \emph{scalability}. For each question (line 04), the populateClassifier clears the body from any html tags inserted by the StackOverflow users to beatify their questions (line 05) and classifies this question's body with each tag. Automatically, the populateClassifier proceeds to the next tag of this question. When the populateClassifier is finished the NB is trained. It should be noted that a question may have more than one tag, so a question can be classified up to five tags / classes. Changing the threshold parameter at the following algorithm, the \emph{populateClassifier} can classified with an arbitrary number of tags. At the following section the process to Bayes classification is described in more details.

\begin{lstlisting} 
01:var tags = ['scalability']
02:populateClassifier(0)
03:function populateClassifier(index) {
04:  var questions = stackexchange.api.getQuestionsByTag(tags[index])
05:  foreach(questions as q)
06:    body = clear(q.body)
07:    foreach(q.tags as t)
08:    	 classify(body, t)
09:    	 if(not tags.exist(t) and tags.length() < threshold)
10:    	   tags.push(t)	  
11:        populateClassifier(tags.indexOf(t))
12:}		
\end{lstlisting}

\subsubsection{Bayes Classification Algorithm}
\textcolor{blue}{In this section the Bayes classification algorithm is being described. As the above code snippet show at line 08, the algorithm classifies a document named \emph{body} into the class \emph{t}. Diving in this function, the \emph{body} transformed to lower case and the Porter Stemming Algorithm~\citep{porter1980algorithm} is used for suffix stripping, so the plural part of the words and the \emph{-ing} and \emph{s} parts of verbs are removed. Thus the following words: {\it connected}, {\it connection}, {\it connections}, {\it connecting} will all be transformed to the single word ``connect''. The Porter Stemming Algorithm is not using any dictionary but a simple list of suffixes which makes the algorithm fast (10.000 different words in 8.1 seconds). After this process the table of words of this \emph{body} is kept.}

\textcolor{blue}{After the populateClassifier has finished, the \emph{trainClassifier} is called (for simplicity not shown in the above code snippet). The work of \emph{trainClassifier} is to make the Bayes Classification ready for process and determine the class of other future documents. So, \emph{trainClassifier} counts for each word the number of occurrences for each class.}

\textcolor{blue}{Since the Classifier is ready, when a future request for classification comes, the Classifier returns for each class the probability to be part of this class. The probability of each class is calculated by following formula:} 
\\
\[prob(d / c) = log\left ( \frac{countedTerms(d, c)}{totalsTerms(c)} \right )\]
\\
\textcolor{blue}{Where the probability of a document {\it d} to be a class {\it c} is the logarithmic value of the division of the words(terms) of {\it d} found in class {\it c} by the total number of terms in {\it c}.}
