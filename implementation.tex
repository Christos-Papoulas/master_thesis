
\chapter{Implementation}
\label{chap:implementation}
This chapter describes the implementation of our social networking site, the User Interface and how the system scales.

The system consists of the following components, as shown in figure~\ref{fig:system_architecture}: In the first layer lives (1) the Social Networking engine, which runs all PHP scripts, as described in section~\ref{sec:implementaion_of_social_netowrk}. 
In the second layer lives (2) the Memcached caching system, which described in section~\ref{sec:memcache_implementation}. 
In the third layer lives (3) the Social Network MySQL database, and (4) the CDO server - client components as well as the CDO repository. The Social Networking Engine at layer 1 is defined as the front end system and the CDO Client, the memcached nodes, the CDO Server and the repositories are defined as the back end system. 

\begin{figure}[h]
	\caption{The overall architecture of Social Network.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/system_architecture.pdf}
	\centering
	\label{fig:system_architecture}
\end{figure}

In order to achieve the scalability of the system, two system architectures are examined at two layers of the system: (1) We added more than one Social Network engines at the first layer of the system. In this implementation, in order to keep the file system in consistent mode we integraded Apache Zookeeper~\cite{zookeeper_url} as described in section~\ref{sec:engine_scale}. (2) We added more than one memcached nodes at the second layer in order to add more cpu capacity and improve the system's response time as described in section~\ref{sec:memcache_implementation}.

\section{Implementation of Social Network}
\label{sec:implementaion_of_social_netowrk}
The social networking platform is implemented over the extensible Elgg social network framework~\cite{elgg_url}.  Elgg is an open source software written in PHP, that uses MySQL for data persistence and supports jQuery~\cite{jquery_url} for client-side scripting.  

The overall architecture of Elgg Social Network is shown in figure ~\ref{fig:elgg_architecture}. The Elgg Social Network is structured following the key concepts of Model-View-Controller (MVC) known architectural pattern for User Interfaces. The MVC system is analyzed here, depicting the most important aspects of it from the Elgg perspective.

Figure~\ref{fig:elgg_architecture} shows the model, view, and controller parts of Elgg's architecture. In a typical scenario, a web client requests an HTML page (e.g., the description of an application model).  The request arrives at the \emph{Controller}, which confirms that the application exists and instructs \emph{Model} to increase the view counter on the application model object. The controller dispatches the request to the appropriate handler (e.g., application model, component handler, community handler) which then turns the request to the view system. View pulls the information about the application model and creates the HTML page returned to the web client.

The {\bf Model} of the framework is structured around the following key concepts as shown in figure ~\ref{fig:elgg_entities}:
\begin{itemize}
\item \emph{Entities}, classes capturing social networking concepts: users, communities, application models. Elgg Core comes with four basic objects: ElggObject, ElggUser, ElggGroup, ElggSite, ElggSession, ElggCache and a lot of other classes necessary for the proper engine operation.
\item \emph{Metadata} describing and extending entities (e.g., a response to a question, a review of an application model, etc.).
\item  \emph{Relationships} connect two entities (e.g., user A is a friend of user B, user C is a contributor to an application model, etc.) and are persisted in the Social Network DB.
\item \emph{Annotations} are pieces of simple data attached to an entity that allow users to leave ratings, or other relevant feedback.
\end{itemize}

\begin{figure}[h]
	\caption{Architecture of the Elgg Social Networking engine.}
	\includegraphics[width=0.9\textwidth,natwidth=200,natheight=150]{./fig/elgg_architecture.pdf}
	\centering
	\label{fig:elgg_architecture}
\end{figure}

All Elgg objects inherit from ElggEntity, which provides the general attributes of an object. Elgg core comes with the following basic entities: ElggObject, ElggUser, ElggGroup, ElggSite, ElggSession, ElggCache, as well as other classes necessary for the operation of the engine.

\begin{figure}[h]
	\caption{The Elgg Engine Data model.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/elgg_data_model.png}
	\centering
	\label{fig:elgg_entities}
\end{figure}

The {\bf controller} component of MVC model of Elgg consisting of the \emph{Actions} of the system which are the primary way the users interact with the Elgg site. An action in Elgg Framework is the code that make changes to the database when a user does something such as logging in, posting a comment, and creating an application model. The action script processes input, makes the appropriate modifications to the database, and provides feedback to the user about the action. By default, actions are only available to logged in users and include Cross-Site Request Forgery (CSRF) Security token to overcome session fixation~\cite{kolvsek2002session}, Session Hijacking~\cite{burgersposter} and Cross-site Scripting~\cite{thamescomparing}.

Additional, the controller component includes the \emph{Events} and the \emph{Plugin Hooks}, which are used in Elgg Plugins to interact with the Elgg engine. Events and hooks are triggered at important times throughout Elggâ€™s boot and execution process, and allows plugins to modify or cancel the default behaviour of Elgg. When an event is triggered, a set of handlers is executed in order of priority. Each handler is passed arguments and has a chance to influence the process. After execution, the ``trigger'' function returns a value based on the behaviour of the handlers.

The {\bf View} component is responsible for creating the output. Generally, this will be HTML sent to a web browser, but it could also be XML, JSON or any other data formats. The Views handles everything from the layout of pages and chunks of presentation output (like a topbar ) down to individual links and form inputs.

Elgg comprises a core system that can be extended through plugins (examples are the Cart system or the handling of Application Models). Plugins add new functionality, can customize aspects of the Elgg engine, or change the representation of pages.
A plugin can create new objects (e.g., ApplicationObject) characterized (through inheritance of ElggEntity) by a numeric globally unique identifier (GUID), owner GUID, Access ID. Access ID encodes permissions ensuring that when a page requests data it does not touch data the current user does not have permissions on. 

The extensibility of Elgg, as mentioned, can be established not by modifying the core system but by introducing new plug-ins which follow the MVC model. A new plug-in can create a new entity. Thus, each entity is characterized by a numeric Globally Unique Identifier and Access ID. The Access ID determines the permissions that other users have. Thus, when a page requests data, it never touches those data that the current user does not have permission to see. All plug-ins share a common structure of folders and PHP files, following the MVC model of figure~\ref{fig:elgg_architecture}. 

The hierarchy of a plug-in is shown in figure~\ref{fig:elgg_hierarchy}. 
Folder {\em actions} includes the actions applied on application models. Every active participation by the user is performed via an action. Logging in, creating, updating or deleting content are all generic categories of actions.
The {\em views} folder contains the {\em php} forms applied on application models, {\em river} events (Elgg terminology for live feeds). Viewss are responsible for creating the output for the client browser. Generally, this will be HTML, but it can be also JSON or other format. 
{\em Pages} overrides elements of core Elgg pages and can be from chunks of presentation output (like sidebars) down to individual html code.  
The {\em js} and {\em lib} folder provides javascript and {\em php} library functions. 
Finally, the {\em vendors} folders include third-party frameworks such as Twitter's bootstrap front-end~\cite{bootstrap_url}.
The most important file of a plug-in is the \emph{start.php} script, which contains the \emph{page handler}. Page handler is a function manages the plug-in pages enabling custom url redirect to a specific page. 
The plug-in initialization is also defined in the start.php and registers actions, events and determines the views. 

\begin{figure}[h]
	\caption{The structure of the application description plug-in.}
	\includegraphics[width=0.4\textwidth]{./fig/folder_hierarchy.png}
	\centering
	\label{fig:elgg_hierarchy}
\end{figure}

Finally, as mentioned before, for client side scripting the jQuery is used. The main reason why jQuery is preferred in this work over of pure JavaScript~\cite{mccormick2004jquery} is that it's a light library which pushes content to the client machine, it therefore reduces the wait time for server response. Plus, it's smaller than Flash, so it results in smoother playbacks and less errors. Furthermore, jQuery works anywhere since is cross-browser compatible with any browser, mobile phone or tablet, and Apple devices. Finally, another hand-solving advantage of jQuery is its simple syntax.It is designed to make it easier to navigate in a document, select HTML DOM elements, create animations, handle events, and developing Ajax applications. 

Thus, the jQuery is used by SNP for implementing client side scripting and for the remaining of this chapter, when we refer to JavaScript, we actually refer to the jQuery library. 
Furthermore, some other JavaScript libraries are used in order to make the User Interface more powerful. One of those libraries is the Chart.js~\cite{chartjs_url} library which is used to generate the graphs and charts in execution's page.

\subsubsection{New functionality of Elgg Social Network Platform}
As described in the previous section, the new functionality of Elgg Social Networking Platform can be introduced by new plugins. The modification of the core system is not a good practice because make the system more difficult to implemented and can not upgrade to the new versions of Elgg framework. Though, the following plugins are implemented:

\textbf{ApplicationModel}. The ApplicationModel plugin has a {\it page handler} to manage the application Model pages. Also, ApplicationModel has client side JavaScript for manipulating User Interaction and dynamic pages. Furthermore, some php libraries are implemented, for example a library for interaction with CDO client or a library for manipulating Application models. 

\textbf{Components}. The Components plugin has a {\it page handler} to manage the Components pages and the Categories of them and a php library to interact with Chef Supermarket.

\textbf{CustomView}. The CustomView plugin has all the necessary customization of the PaaSage Social Networking Platform (PSNP). All custom views of the system are implemented in this plugin. This plugin overrides all the default views of the Elgg that should be changed and contains client side JavaScript. Furthermore, CustomView has the following seven page handlers: {\t profile} responsible for profile pages, {\t avatar} responsible for the photos of user pages, {\t settings} responsible for the pages of user settings, {\t friends} responsible for the friends of the user pages, {\t contact} responsible for the Contact Information of the PSNP, {\t review} responsible for the reviews of Application Models and {\t search} responsible for the main search facility of PSNP. Finally, CustomView has all the required \emph{Actions} of the plugin such as the vote up or down, the action of add a review etc.

\textbf{NotificationSystem}. This plugin is responsible for the notifications of the Social Network which contains a relevant page handler, JavaScript for client side scripting and a php server side library.

\textbf{Tags}. This plugin does not include any page handler but only the necessary actions for the Tags such as {\it add} or {\it delete} a Tag and a php library responsible for those. 

\textbf{UserStatistics}. This plugin is responsible for collecting and displaying the information about the Users.

\textbf{Memcached}. This plugin has all the essential functionality for memcached implementation as will described in section~\ref{sec:memcache_implementation}.

\textbf{ZookeeperRecipes}. This plugin has all the essential functionality for memcached implementation as will described in section~\ref{sec:engine_scale}.

\textbf{Groups}. The Groups plugin is the default plugin of Elgg Framework modified to support the required functionality.

\textbf{Messages}. The Messages plugin is the default plugin of Elgg Framework modified to support the required functionality.

\subsubsection{Twitter bootstraping of Elgg}
Twitter Bootstrap~\cite{twitter_bootstrap}~\cite{cochran2012twitter} is a free and open-source collection of tools for creating dynamic websites and web applications. It contains HTML and CSS-based design templates for typography, forms, buttons, navigation and other interface components, as well as optional JavaScript extensions. It aims to ease the development of dynamic websites and web applications. 

We customize the Elgg View inserting the Twitter Bootstrap View System. The default View System of Elgg changed to support the Bootstrap responsive grid.

\subsection{CDO communication with Social Networking Platform}
\label{sec:cdo_comm}
As mentioned in~\ref{sec:background}, the execution history of deployments of application models and the description of those models are stored in the CAMEL information repository, which is implemented as an Eclipse CDO server. In order to communicate with the CDO Server, a CDO Java Client is needed. The CDO client is in the middle between the Social Networking Engine (Elgg Server) and the CDO server, making possible the exchange of information between those two as shown in figure~\ref{fig:system_architecture}.

Specifically, for the communication between the CDO Server and the Client, the CDO Client opens one or more sessions to the CDO Server. Each session represents a connection to the CDO repository and provides a broad API to interact with it. A session does not provide direct access to model instances; views or transactions are needed to navigate or modify the model instance graph. The implemented CDO Client expose read/write access to the repository for viewing the execution histories or the model of the applications, or store new execution models. For the communication between the Social Networking Engine and the CDO Client, the CDO Client expose a RESTful API to the Social Networking engine providing all the necessary methods. 

For example, when a user from the Social Network requests the execution histories of an application, the Engine sends a request to the CDO Client through the RESTful API, the CDO Client receives the request and forwards an appropriate request to the CDO Server. The CDO Server receives the request and queries the Repository of Application models and executions. When the CDO Server receiving the response, it forwards the response back to the CDO Client, which forwards the response back to the Social Networking Engine. The Social Networking Engine transforms the response to JSON format, in order to be readable by the JavaScript. JavaScript plays the final role, by viewing the execution histories to a proper table to the user that request the page of the executions of application.

\section{Scaling Social Network Engine}
\label{sec:engine_scale}

This subsection describes how the horizontal scale of Social Network engine achieved. At the layer 1 of figure~\ref{fig:elgg_architecture} lives the Apache2 server which as the stress test of the system shows in chapter~\ref{chapt:evaluation}, the Apache2 server takes a heavy load on CPU utilization. 

The heavy load of Apache2 server occurs by the nature of Elgg Framework. Because the Elgg core system is implemented to be extensible and configurable, at every time a simple page or just an AJAX call is received by the Elgg, the Elgg Framework performs the following heavy task: broadcasts an {\it init system} event; this event is caught by all plugins of Elgg and at this initialization phase the plugins registers (1) the page handlers, (2) the php libraries, (3) the actions, (4) the events and hooks, (5) the JavaScript libraries and (6) the CSS scripts. Therefore, we introduce more than one Apache2 Servers running the Social Networking Engine of Elgg Framework.  

The Social Networking Engine keeps some information in the file system instead of the Social Network DB. This information includes the profile photos of users and any other photo such as photos that users add to the community groups. Furthermore, the initial configuration of Social Networking Engine keeps in the file system some caching files representing some views which are independent from specific users and do not change among all users. This file system caching feature removed from the Social Network Engine because is more efficient to use memcached for the caching instead of the slow file system.

The Network File System (NFS) is configured and used in order to all SN Engines have access to the same file system store. An NFS server installed in one of the SN Engines and all the other SN Engines have an NFS client accessing the remote file system.   

Distributing Social Network Engine was not an easy problem, so Apache ZooKeeper~\cite{zookeeper_url} is used to enable highly reliable distributed coordination among access to the file system storing by Social Networking Engine. 
Apache ZooKeeper provides a tree abstraction where every node in that tree (or znode) is a file on which a variety of simple operations can be performed. ZooKeeper orders operations on znodes so that they occur atomically. Therefore there is no need to use complex locking protocols to ensure that only one process can access a znode at a time. The tree represents a hierarchical namespace, so that many distinct distributed systems can use a single ZooKeeper instance without worrying about their files having the same name.

Social Networking Engine uses Apache ZooKeeper in order to keep consistent the file system in rear but possible scenarios such as two users try to upload in the same time a file to the same group. When a SN Engine wants to write a file in file system first locks the specific path and after finish the write operation releases the lock.

For communication between the Apache ZooKeeper and the Elgg framework, the php-zookeeper-recipes~\cite{zookeeper_recipes_url} are used by the ZookeeperRecipes plugin. Specifically, the {\it exclusive locks} of Zookeeper are used to keep the system in consistent mode.

\section{Memcache}
\label{sec:memcache_implementation}
This section describes the experience gained by using memcached~\cite{memcache_url}. Memcached is an open source, high-performance, distributed memory object caching system. We choose memcached, because is a generic simple in-memory key-value store. It has a powerful API available for php. After memcached integration the system increase the response time and the performance.

Memcached added in layer 2 of system architecture and used for storing the following key-value tuples: (1) values from Social Network Database such as entities of Social Network, applications, components, users, group discussions, (2) evaluated javascript code results and (3) executions histories from repository of application models. Storing the executions of applications at Memcached the response time of the system increased because the PHP modules do not need to go through the heavy CDO client but get directly the executions of applications from Memcached.

The apache jmeter~\cite{jmeter_url} was used to measure the responce time of the system and the sysstat tool~\cite{sysstat_url} was used to measure the cpu usage. Section~\ref{sec:eval_memcache} 
 shows the performance results of this implementation.

All tuples at Memcached are inserted with maximum key expiration time of thirty days. When a value in social network is updated, the memcached key will deleted as shows the figure~\ref{fig:memcache_key_value}.

\begin{figure}[h]
	\caption{The scenario a depicts a request from memcached when the key does not exist and scenario b depicts a updated operation of a value) }
	\includegraphics[width=0.9\textwidth]{./fig/memcached_key_value.pdf}
	\centering
	\label{fig:memcache_key_value}
\end{figure}

The Elgg Framework comes with the potentiality to use memcached but is restricted to the facts that a memcached node must to be in the same machine as the Elgg Framework and makes more difficult to configure and strict when an insertion in memcached node will take place. Therefore, a new plugin is implemented called \textbf{Memcached} using the memcached php library~\cite{memcached_php_doc}. The basic memcached functions offered by this plugin are: (1) Add memcached nodes, (2) add a key to a node, (3) get a value of a key and (4) delete a key-value item. 

\section{Natural Language Processing and classification}
\label{sec:natural_implementation}
Natural Language Processing(NLP)~\cite{manning1999foundations} is a feature added to the Social Network. NLP is used in the interactions between the users and the SN and in the way the platform can understand and determine the type of user input. Particularly, Naivy Bayes Natural Language Understanding algorithm is added to the SN using the Natural framework~\cite{nodenatural_url} implemented with node.js. In general, Machine Learning algorithms such as Naivy Bayes, want an input, calling data set, of training data, this training data is pulled from StackOverflow (SO) questions. Those questions are an excellent repository to train the NB algorithm, because is categorised by tags and in the time that this implementation was took place, the Social Network had not a good repository of many questions.

In general, the main actions of SO members is shown in figure~\ref{fig:stackoverflow_questions}. When users ask questions in SO, they must specify some tags describing their questions. A tag is a keyword or label that categorizes their question with other, similar questions. The users of SO sometimes, try to add as much tags as possible in order to make their questions popular and get them answered. SO restricts the users to add up to five tags in each of their questions. After a question is posed, the community of SO can vote up or down the question or privileged users can flagged the question as \emph{duplicate}, \emph{off-topic}, \emph{unclear}, \emph{too board} or \emph{primarily opinion-based}. So low quality questions will can be removed from the site and keep the questions repository clear and helpful to other potential developers.

For the training sets, which is the data to train the NB algorithm, the most voted question of the SO community is used. Those questions have emerged as the good questions in their fields and surely, we avoid the case to use a training set with miss-tagged questions which would result a miss-guided NLP classification. The NLP training set is retrieved from SO site using the stack exchange(SE) API~\cite{stackexchange_url}. The SE API is a powerful API, which allows to take the questions, the answers, the users and all the information that exists in SO site through a programming interface.

\begin{figure}[h]
	\caption{The main StackOverflow users' actions and NLP Classifier. }
	\includegraphics[width=0.9\textwidth]{./fig/StackOverFlow.pdf}
	\centering
	\label{fig:stackoverflow_questions}
\end{figure}

The first training set of our Natural Processing Tool consisted of five tags, relative to our platform. Those tags were: \emph{scalability}, \emph{reliability}, \emph{design}, \emph{performance} and \emph{optimization} with thirty questions per tag. For each of the tags, the thirty most voted questions from StackOverflow were retrieved and classified to each specific tag. Those exactly tags, after classification, are transformed in classes in NLP classification, as shows the figure~\ref{fig:stackoverflow_questions}

Every time a user asks a question to a platform's community, the classifier determines the class of the question. Then, if the platform is able to determine a heuristic answer, it will post it to the user's question. All the users of the platform can vote up or down this answer, depending on its accuracy, or provide their own answers.

The second training set of Natural Processing Tool was retrieved by automatically discovering tags. NB is trained with 10K questions from StackOverflow Q\&A site, fifty questions per tag. The general algorithm is shown below. Firstly, the algorithm starts with a tag which is relevant to the Social Network Platform such as \emph{scalability} at line 01. Afterwards, using the SE API the algorithm gets the 5 most voted questions tagged with \emph{scalability}. For each question (line 04), the populateClassifier clears the body from any html tags inserted by the StackOverflow users to beatify their questions (line 05) and classifies this question's body with each tag. Automatically, the populateClassifier proceeds to the next tag of this question. When the populateClassifier is finished the NB is trained. It should be noted that a question may have more than one tag, so a question can be classified up to five tags / classes. Changing the threshold parameter at the following algorithm, the \emph{populateClassifier} can classified with an arbitrary number of tags. At the following section the process to Bayes classification is described in more details.

\begin{lstlisting} 
01:var tags = ['scalability']
02:populateClassifier(0)
03:function populateClassifier(index) {
04:  var questions = stackexchange.api.getQuestionsByTag(tags[index])
05:  foreach(questions as q)
06:    body = clear(q.body)
07:    foreach(q.tags as t)
08:    	 classify(body, t)
09:    	 if(not tags.exist(t) and tags.length() < threshold)
10:    	   tags.push(t)	  
11:        populateClassifier(tags.indexOf(t))
12:}		
\end{lstlisting}

\subsection{Bayes Classification Algorithm}
In this section the Bayes classification algorithm is being described. As the above code snippet shows at line 08, the algorithm classifies a document named \emph{body} into the class \emph{t}. Diving in this function, the \emph{body} is transformed to lower case and the Porter Stemming Algorithm~\citep{porter1980algorithm} is used for suffix stripping, so the plural part of the words and the suffixes are removed (such as \emph{-ing} and \emph{s}). Thus the following words: {\it connected}, {\it connection}, {\it connections}, {\it connecting} will all be transformed to the single word ``connect''. The Porter Stemming Algorithm is not using any dictionary but a simple list of suffixes which makes the algorithm fast (10.000 different words in 8.1 seconds). After this process a table of words of this \emph{body} is kept.

After the populateClassifier has finished, the \emph{trainClassifier} is called (for simplicity not shown in the above code snippet). The objective of \emph{trainClassifier} is to make the document body ready for Bayes Classification. So, \emph{trainClassifier} counts the number of occurrences of each word in each class.

Since the Classifier is ready, when a future request for classification comes, the Classifier returns the probability for each class to be part of this class. The probability of each class is calculated with the following formula:
\\
\[prob(d / c) = log\left ( \frac{countedTerms(d, c)}{totalsTerms(c)} \right )\]
\\
Where the probability of a document {\it d} to be a class {\it c} is the logarithmic value of the division of the words(terms) of {\it d} found in class {\it c} by the total number of terms in {\it c}.

\subsection{Automated answers from Natural Language Processing}
\label{sec:example_nlp}
As described in section~\ref{sec:natural_implementation} Natural Language Processing is used to determine the users' input question in groups. When a user asks a question, the body of the question classified into categories and when the NLP classifies the question to a specific category, an approximate answer can be given in response. As shown in figure~\ref{fig:nlp_example}, after the user's question, the classifier process the body and if the question is about the {\it JEnterprise} and the {\it cost effectivess} the approxiame answer ``The most cost effectiveness configuration of SPEC JEntreprise2010 is: jEnterprise18F \ldots'' is given. The users of the PaaSage Social Network Platform can vote up or down the answer and/or provide their own answers.
\begin{figure}
  \centering
  \includegraphics[scale=0.6]{./fig/nlp_example.png}
  \caption{Automated answer to user's question using NLP.}
  \label{fig:nlp_example}
\end{figure}


\section{User interface}
In this section described the User Interface of Social Network implementated based on 104 mock-ups created by HCI expert team. In order to support those look \& feel and the functionality of those mock-ups 25K lines of php, js and css code is written.
The key design objective of the social network platform is to create a strong bond between (i) software engineering services for managing and deploying cloud-targeted application models; and (ii) community-oriented facilities for communication and
collaboration between users. The interconnections between the two in the design of the user interface are depicted in Figure \ref{fig:two_aspects}.
The prototype implementation is publicly accessible on-line at http://socialnetwork.paasage.eu. 

\begin{figure}[h]
	\caption{The engineering \& social activities are seamlessly within the Platform.}
	\includegraphics[width=0.6\textwidth,natwidth=200,natheight=150]{./fig/two_aspectes.png}
	\centering
	\label{fig:two_aspects}
\end{figure}

\subsection{User Interface Design Principles}
The discrete entities, which bound together the Social Networking with application model aspects of Platform are:
\begin{itemize}
\item \emph{Application Models}. Application Models is a key entity of the platform. An example is shown if figure \ref{fig:jenter_home}, consisting of a human friendly description (label 1 in fig.\ref{fig:jenter_home}), the Camel Description of the model (label 2 in fig.\ref{fig:jenter_home}), reviews about the model (label 3 in fig.\ref{fig:jenter_home}). An overview of engineering aspects such as version and runs (label 4 in fig.\ref{fig:jenter_home}) and an overview of social aspects such as share and watch (label 5 in fig.\ref{fig:jenter_home}). The {\it share} action broadcast the model to the friends of the user that shares the model. The {\it watch} action notifies the user for future updates of the application model. 
\item \emph{Components}. We have integrated the Chef supermarket components into Social Network Platform. The components help the DevOps users to generate their application models as described in~\ref{sec:automatedcreation}. 
\item \emph{Users}. Users which basically be Cloud Deployment specialists and other users who want to know which deployment configuration should use. Users can exchange knowledge to groups and benefit from CAMEL repository. They can create or join groups, ask and answer questions, follow application models and create their own network of friends.
\item \emph{Groups}. Every user of PaaSage Social Network Platform can create or join groups. Groups help users to interact with each other and gain knowledge from experts.
\end{itemize}

\begin{figure}[h]
	\caption{The application model home page}
	\includegraphics[width=1\textwidth,natwidth=200,natheight=150]{./fig/jenterprise_home_page.pdf}
	\centering
	\label{fig:jenter_home}
\end{figure}

\subsubsection{Gamification}
Following recent trends in social networks design and with the aim to motivate users active and regular participation in
the professional network, the design employs gamification features, namely use of video game elements to improve user experience and user engagement in non-game services and applications~\cite{deterding2011gamification}. One gamification feature in the Social Network design is the reward system for active community members. As users contribute content (models, components, ratings, reviews, questions, or answers) they receive experience points leading to special badges visible to all community members. Other features are the Profile completeness bar with suggestions on how to increase it. Finally, the concept of Model badges awarded to application and component models in case of excelling performance. Badges can serve among others as goal-setting devices, status symbols, and indications of reputation assessment procedures~\cite{antin2011badges}.

\subsection{Automated Application Model Creation}
\label{sec:automatedcreation}
The DevOps users of PaaSage Social Network Platform can benefit from the automated creation of CAMEL baseline models or upload their own created models using external editors like EMF~\cite{cdomodel} tree based editor or GMF~\cite{gmf_url} editor. 

In order users to create automated generated baseline CAMEL models, they can browse around the integrated Chef Components inside the Social Network and find the appropriate components for their applications. The platform has integrate a pointer for each Chef cookbook to the Social Network Database using the Chef Supermarket API~\cite{chef_api_url}. A PHP command has implemented in order to iterate through all Chef cookbooks and update the repository of SNP. This command has been configured and runs one time every day.

Through the Application Model Creation Page of the PaaSage Social Network Platform, the users can upload an external CAMEL model description of their application or create a new one with the help of the Platform in 4 simple steps as shown in figure ~\ref{fig:model_creation_0}. In the step zero~\ref{fig:sfig0}, the user asked if the new Application model has already an CAMEL model or the user want to create a new Application CAMEL model through automated generation. For automated generation the users should have put in the user's cart the Chef cookbooks that wants. Then, in step one~\ref{fig:sfig1}, the user selects from his/her list of components which of those will be included in the Application Model. 
As the figure~\ref{fig:sfig1} shows, the user has four components {\it mysqld}, {\it apache2}, {\it nodejs} and 
{\it ruby\_installer} and selects three of them. In the next step, shown in figure~\ref{fig:sfig2} the user provides the deployment information (to which cloud provider the Application will run and which type of VMs will be used). Also, some components, in this example the {\it nodejs} component will be collocated in the same VM as the {\it apache2}. In step tree, shown in figure~\ref{fig:sfig3}, the user provides the communication information between the components, for example the 
{\it nodejs} communicates with {\it mysqld} in the default mysql port {\it 3306}.

In the final step as shown in figure~\ref{fig:sfig4}, the user provides the final needed information about the name of the Application model, a human friendly description and the version of the model. In the bottom of the form of the figure~\ref{fig:sfig4} the user can find three actions: the \emph{Previous} action, the \emph{Save as draft} action and the \emph{Finalize} action. The \emph{Previous} action can performed all around the steps and make the user easily walk around the steps. The \emph{Save as draft} action creates the CAMEL model of the application but the model is publicly available and the creator or the contributors of the Application can edit the Model. At the \emph{Finalize} action, the model is now publicly available to the PaaSage Social Network users.

\begin{figure}
\begin{subfigure}{.8\textwidth}
  \centering
  \includegraphics[scale=0.4]{./fig/model_creation0.png}
  \caption{Step 0: Upload external or create baseline model.}
  \label{fig:sfig0}
\end{subfigure} \\[1ex]
\begin{subfigure}{.8\textwidth}
  \centering
  \includegraphics[scale=0.4]{./fig/model_creation1.png}
  \caption{Step 1: Choose the Components from the users' list.}
  \label{fig:sfig1}
\end{subfigure} \\[1ex]
\begin{subfigure}{.8\textwidth}
  \centering
  \includegraphics[scale=0.4]{./fig/model_creation2.png}
  \caption{Step 2: Deployment information.}
  \label{fig:sfig2}
\end{subfigure} \\[1ex]
\begin{subfigure}{.8\textwidth}
  \centering
  \includegraphics[scale=0.4]{./fig/model_creation3.png}
  \caption{Step 3: Communication Information.}
  \label{fig:sfig3}
\end{subfigure} \\[1ex]
\caption{Steps for Automated creation of baseline model.}
\label{fig:model_creation_0}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[scale=0.4]{./fig/model_creation4.png}
  \caption{Final Step of Automated creation of baseline model.}
  \label{fig:sfig4}
\end{figure}

\clearpage

\subsection{Graphical modeling of applications}
\label{sec:gmf}

Advanced users of the PaaSage Social Network Platform can compose application models through Graphical Modeling Framework (GMF)~\cite{gmf_url} which is an external Eclipse editor. GMF provides a set of generative components and runtime infrastructures for developing graphical editors based on Eclipse Modeling Framework (EMF) and Graphical Editing Framework (GEF). The GMF editor is generated from CAMEL {\em ecore} schema and provides the graphical palette to compose applications. 

Figure~\ref{fig:sensapp_as_gmf} shows the composition of a sample application model with the GMF editor. The palette in the right, contains all nodes and relationships needed to describe an application model. In the center, the composition of a sample application is shown, consisting of three VM types, the VM information about these VMs and the owner/user of the application. The GMF editor generates two files, one responsible for the graphical representation and the XMI description of the application model that can be uploaded to the social networking platform.

\begin{figure}
  \centering
  \includegraphics[scale=0.6]{./fig/gmf_editor.png}
  \caption{GMF editor composition of a sample application.}
  \label{fig:sensapp_as_gmf}
\end{figure}
